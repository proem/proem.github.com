<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Proem Framework &mdash; A lightweight, simple, fast MVC implementation for PHP5.4</title>
    <meta name="description" content="">
    <meta name="author" content="Tony R Quilkey">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="expires" content="0">

    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="/scripts/bootstrap.min.js"></script>
    <script src="/scripts/prettify.js"></script>
    <script src="/scripts/proem.js"></script>

    <link rel="stylesheet" type="text/css" href="/styles/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/styles/bootstrap-responsive.min.css">
    <link rel="stylesheet" type="text/css" href="/styles/prettify.css">
    <link rel="stylesheet" type="text/css" href="/styles/proem.css">
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-21713077-3']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
  </head>
  <body>
    <div class="topnav">
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <div class="brand">
            <strong>Proem</strong> Framework
          </div>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="https://github.com/proem/proem/issues">Issues</a></li>
              <li><a href="/docs">Documentation</a></li>
              <li><a href="/contrib.html">Contribute</a></li>
              <li><a href="/about.html">About</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
    <div class="docs container">
      <div class="row">
        <div class="span3">
          <ul class="nav nav-tabs nav-stacked">
            <li><a href="/docs">Overview</a></li>
            <li><a href="/docs/installation.html">Installation</a></li>
            <li><a href="/docs/autoloader.html">The Autoloader</a></li>
            <li><a href="/docs/cascading-namespace.html">The Cascading Namespace</a></li>
            <li><a href="/docs/bootstrap.html">The Bootstrap Process</a></li>
            <li><a href="/docs/opt-component.html">The Opt Component</a></li>
            <li><a href="/docs/route-component.html">Routing</a></li>
            <li><a href="/docs/signal-component.html">Signals</a></li>
            <li><a href="/docs/services-component.html">Dependency Injection</a></li>
          </ul>
        </div>
        <div class="span9">
          <div class="well">
  <h2>The Opt Component</h2>
  <p>
    One of the new features of PHP5.4 is the ability to use a short version array syntax. Previously
    when creating arrays you had to use the language construct array().
  </p>
  <pre class="prettyprint">
    $a = array('foo' => 'bar');
  </pre>
  <p>The new syntax is shorter, simpler and in my opinion much cleaner:</p>
  <pre class="prettyprint">
    $a = ['foo' => 'bar'];
  </pre>
  <p>
    The <em>Opt</em> component has been designed to take advantage of this shorter syntax and to use
    it to provide a simple form of <em>named arguments</em> for functions.
  </p>
  <pre class="prettyprint">
    somefunction(['foo' => 'bar', 'boo' => 'bob']);
  </pre>
  <p>
    Using this you no longer need to worry about what order arguments are passed into a function and
    they also provide a relatively simple form of self documentation in the location where a function
    is actually called.
  </p>
  <p>
    A more complete example (taken directly from the event manager prototype code I'm working on) looks something like:
  </p>
  <pre class="prettyprint">
    $events->attach([
        'name'      => 'do',
        'priority'  => 100,
        'callback'  => function($e) {
            echo "Do something\n";
        }
    ]);
  </pre>
  <p>
    Astute readers will be thinking cool, so your passing an array to a function instead of arguments. Big deal why
    do we need a component for this? And what about type hinting?
  </p>
  <p>
    Indeed <em>type hinting</em> is a requirement of many good designs. This is why I created a component to handle
    this type of <em>named argument</em> implementation. The component is responsible for validating the type of
    each parameters passed based on a set of rules that you describe.
  </p>
</div>
<div class="well">
  <h3>How?</h3>
  <p>
    I have played with this component for a number of weeks now and blogged about several different prototypes on
    my blog <a href="http://thorpesystems.com/2011/11/implementing-mootools-options-in-php">here</a> and
    <a href="http://thorpesystems.com/2011/12/further-prototyping-options">here</a>, in the end, I have gone with
    something similar to the implementation initially shown in the later link.
  </p>
  <p>
    The Opt component consists of a trait, <em>Options</em> and a class <em>Option</em>. The <em>Options</em> trait provides a
    single method setOptions(). This method accepts an array of rules, plus the array of arguments passed to the function / method.
    The <em>Option</em> class is instantiated into an object and is used to define default argument values, as well as any
    validation rules that need to be applied to this argument. A simple example might illustrate this better:
  </p>
</div>
<div class="well">
  <h3>Default values & required params</h3>
  <pre class="prettyprint">
    use \Proem\Util\Opt\Options,
        \Proem\Util\Opt\Option;

    class example
    {
        use Options;

        public function foo(array $options = array())
        {
            $ops = $this->setOptions([
                'foo' => (new Option('somevalue')),
                'bar' => (new Option())->required()
            ], $options);
        }
    }
  </pre>
  <p>
    The above example sets a default value for the param "foo" to "somevalue", it also applies a rule to the "bar" param
    stating that it is a required param. These rules are then applied to the data passed in by the user through the
    $options array any value are merged and the result is returned to the $ops variable as a StdClass object.
    Calling this function:
  <p>
  <pre class="prettyprint">
    $example->foo(['bar' => 'trq'];
  </pre>
  <p>
    $ops would look something like:
  </p>
  <pre>
    object()#1 (2) {
      ["foo"]=>
      string(9) "somevalue"
      ["bar"]=>
    string(3) "trq"
  }
  </pre>
  <div class="alert alert-info">
    The setOptions() method actually returns a <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Util/Opt/Payload.php">Proem\Util\Opt\Payload</a>
    object which in turn is an extension of the <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Util/Storage/KeyValStore.php">Proem\Util\Storage\kayValStore</a> object.
  </div>
  <p>
    If we override the default value for the "foo" param, we will end up with that new value. eg;
  </p>
  <pre class="prettyprint">
    $example->foo(['bar' => 'trq', 'foo' => 'someothervalue'];
  </pre>
  <p>
    Now $ops would look something like:
  </p>
  <pre>
    object()#1 (2) {
      ["foo"]=>
      string(14) "someothervalue"
      ["bar"]=>
      string(3) "trq"
    }
  </pre>
</div>
<div class="well">
  <h3>Checking for incorrect or missing params</h3>
  <p>
    Trying to call the foo() function without passing a "bar" param will result in an InvalidArgumentException being
    thrown so you will want to wrap your call to setDefaults() in a catch block:
  </p>
  <pre class="prettyprint">
    try {
        $ops = $this->setOptions([
            'foo' => (new Option('somevalue')),
            'bar' => (new Option())->required()
        ], $options);
    } catch (\InvalidArgumentException $e) {
        echo $e->getMessage();
    } catch (\RuntimeException $e) {
        echo $e->getMessage();
    }
  </pre>
  <p>
    Notice that we are also looking to catch a Runtime exception? This has to do with <em>type validators</em> and will
    be thrown when you try to check your value against a <em>type validator</em> that isn't defined (See <a href="#type-validators">Type Validators</a>).
  </p>
</div>
<div class="well">
  <h3>Throwing custom exceptions.</h3>
  <p>
    While an InvalidArgument exception is somewhat useful, you might want to take a custom action when a particular
    parameter fails to pass validation. You can do this by setting a custom exception to be thrown.
  </p>
  <pre class="prettyprint">
    try {
        $ops = $this->setOptions([
            'foo' => (new Option('somevalue')),
            'bar' => (new Option())->required()->throws(function() {
                return new missingBarException('Bar is a must have!');
            })
        ], $options);
    } catch (missingBarException $e) {
        echo $e->getMessage();
    } catch (\InvalidArgumentException $e) {
        echo $e->getMessage();
    } catch (\RuntimeException $e) {
        echo $e->getMessage();
    }
  </pre>
  <p>
    The throws() method excepts a closure which must return an instantiated and valid Exception.
  </p>
</div>
<div class="well">
  <h3>Making a required param optional when some other param exists</h3>
  <p>
    We can also set a rule that will make a param required, unless another param (or params) exist.
  </p>
  <pre class="prettyprint">
    $ops = $this->setOptions([
        'foo' => (new Option())->required()->unless('bar')
    ], $options);
  </pre>
  <p>
    The above example says "foo" is a required param unless the "bar" param exists then it is optional.
    Below, we make "foo" required unless both "bar" and "boo" are provided:
  </p>
  <pre class="prettyprint">
    $ops = $this->setOptions([
        'foo' => (new Option())->required()->unless(['bar', 'boo'])
    ], $options);
  </pre>
  <a name="type-validators"></a>
</div>
<div class="well">
  <h3>Type validators</h3>
  <p>
    So, what the heck is a <em>type validator</em>? Besides checking to see that a param exists, we can also
    check to see that this value is of a specific type. We do this by calling the type() method.
  </p>
  <pre class="prettyprint">
    $ops = $this->setOptions([
        'foo' => (new Option())->type('int')
    ], $options);
  </pre>
  <p>
    This checks to see if the "foo" param is of type integer. If it is not, again, an InvalidArgumentException
    will be thrown. There are currently 6 types that you can check for:
  </p>
  <ul>
    <li>array</li>
    <li>bool</li>
    <li>float</li>
    <li>int</li>
    <li>callable</li>
    <li>object</li>
  </ul>
  <p>
    Trying to check for a type other than one of the types defined above will result in the RuntimeException exception being thrown.
  </p>
</div>
<div class="well">
  <h3>Custom type validators</h3>
  <p>
    In conjunction with the type validators defined above, you can also define your own on the fly:
  </p>
  <pre class="prettyprint">
    $ops = $this->setOptions([
        'foo' => (new Option())
            ->addTypeValidator('username', function($value) {
                return preg_match('/^[a-z\d_]{5,20}$/i', $value);
            })->type('username')
    ], $options);
  </pre>
  <p>
    This makes it very easy to customise type checking depending on your needs.
  </p>
</div>
<div class="well">
  <h3>Checking for objects & classes</h3>
  <p>
    Besides the <em>type validators</em> described above there are two other methods available. object() checks to see
    wether or not the value of a param is an instance of a particular object and classof() checks to see if the value
    of a param is a valid string representation of a class.
  </p>
  <pre class="prettyprint">
    $ops = $this->setOptions([
        'pr' => (new Option())->object('Proem\Proem'),
        'pr2' => (new Option())->classof('Proem\Proem')
    ], $options);
  </pre>
  <div class="alert alert-info">
    There is a subtle difference between these two methods. Object validates an *instance* of an object, while classof()
    simply needs a string representation of a class name.
  </div>
</div>
        </div>
      </div>
    </div>
      </body>
</html>
