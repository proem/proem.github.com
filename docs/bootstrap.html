<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Proem Framework &mdash; A lightweight, simple, fast MVC implementation for PHP5.4</title>
    <meta name="description" content="">
    <meta name="author" content="Tony R Quilkey">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="expires" content="0">

    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="/scripts/bootstrap.min.js"></script>
    <script src="/scripts/prettify.js"></script>
    <script src="/scripts/proem.js"></script>

    <link rel="stylesheet" type="text/css" href="/styles/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/styles/bootstrap-responsive.min.css">
    <link rel="stylesheet" type="text/css" href="/styles/prettify.css">
    <link rel="stylesheet" type="text/css" href="/styles/proem.css">
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-21713077-3']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
  </head>
  <body>
    <div class="topnav">
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <div class="brand">
            <strong>Proem</strong> Framework
          </div>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="https://proemframework.atlassian.net">Issues</a></li>
              <li><a href="/docs">Documentation</a></li>
              <li><a href="/contrib.html">Contribute</a></li>
              <li><a href="/about.html">About</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
    <div class="docs container">
      <div class="row">
        <div class="span3">
          <ul class="nav nav-tabs nav-stacked">
            <li><a href="/docs">Overview</a></li>
            <li><a href="/docs/installation.html">Installation</a></li>
            <li><a href="/docs/autoloader.html">The Autoloader</a></li>
            <li><a href="/docs/cascading-namespace.html">The Cascading Namespace</a></li>
            <li><a href="/docs/bootstrap.html">The Bootstrap Process</a></li>
            <li><a href="/docs/opt-component.html">The Opt Component</a></li>
            <li><a href="/docs/route-component.html">Routing</a></li>
            <li><a href="/docs/signal-component.html">Signals</a></li>
            <li><a href="/docs/services-component.html">Dependency Injection</a></li>
          </ul>
        </div>
        <div class="span9">
          <div class="well">
  <h2>The Bootstrap Process</h2>
  <p>
    The process of bootstrapping a framework / application is just a fancy name for <em>setting things up</em>. Generally this
    entails instantiating some objects, setting some parameters and then calling some method to get the framework up and running.
    This usually happens within your index.php file or some other file included into it.
  </p>
  <p>
    In most frameworks, what happens once this process is started is something of <em>black box</em>, the next thing you know, your
    controller is producing a web page. Unless you have a deep understanding of how the framework works this process can feel like <em>magic</em>.
  </p>
  <p>
    While this can make it easy to get started building applications with the default functionality your framework provides, it can also
    make the task of customising this process quite daunting to someone who doesn't really want to dig into a frameworks internals.
  </p>
  <div class="alert alert-info">
    One of Proem's main objectives was to <strong>simplify this process</strong> and make the logic <strong>easy to follow, understand</strong> and <strong>customise</strong>.
  </div>
</div>
<div class="well">
  <h3>Bootstrapping Proem</h3>
  <p>
    Bootstrapping the Proem framework with only defaults is as simple as:
  </p>
  <pre class="prettyprint">
    (new \Proem\Proem)->init();
  </pre>
  <p>
    However, that doesn't really help us much. Below, we are going to describe what exactly happens when you call Proem's <a href="http://dev.web/docs/bootstrap.html#init">init()</a> method, and later
    how you can attach code to <em>Events</em> that will allow you to customise this process.
  </p>
</div>
<div class="well">
  <h3>The Proem Object</h3>
  <p>
    The Proem object is a home for your application and your entire application runs inside of this single object. It is responsible for setting
    up all of the low level infrastructure that your application needs in order to execute. Without it, the bootstrap process would be far more
    tedious. It provides you with an interface for configuring the framework and your application while still allowing a great deal of flexibility
    through the methods it exposes.
  </p>
  <p>
    So let's have a look at what the Proem object actually does. Starting the with __construct:
  </p>
  <pre class="prettyprint">
    public function __construct()
    {
        $this->events = new Asset;
        $this->events->set('\Proem\Signal\Manager\Template', $this->events->single(function($asset) {
            return new SignalManager;
        }));

        $this->serviceManager = new ServiceManager;
    }
  </pre>
  <p>
    From this small snippet we can see that Proem sets up a <a href="/docs/signal-component.html">Signal Manager</a> and a <a href="/docs/services-component.html">Service Manager</a>.
    (Asset is an alias of <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Service/Asset/Standard.php">\Proem\Service\Asset\Standard</a>).
    These two objects are passed around the entire bootstrap process and into your application.
  </p>
  <p>
    So what else? Let's take a look at the actual <a href="http://dev.web/docs/bootstrap.html#init">init()</a> method:
  </p>
  <a name="init"></a>
  <pre class="prettyprint">
    public function init($environment = null)
    {
        $this->serviceManager->set('events', $this->events);

        $this->events->get()->trigger([
            'name'  => 'proem.init',
            'event' => (new Bootstrap)
                ->setServiceManager($this->serviceManager)
                ->setEnvironment($environment)
        ]);

        (new FilterManager($this->serviceManager))
            ->attachEvent(new Event\Response, FilterManager::RESPONSE_EVENT_PRIORITY)
            ->attachEvent(new Event\Request, FilterManager::REQUEST_EVENT_PRIORITY)
            ->attachEvent(new Event\Route, FilterManager::ROUTE_EVENT_PRIORITY)
            ->attachEvent(new Event\Dispatch, FilterManager::DISPATCH_EVENT_PRIORITY)
            ->init();
    }
  </pre>
  <p>
    From this small snippet it is easy to see that init() stores some events within the Service Manager (these are added via <em><a href="#attach-events">attachEventListener</a></em>), it then triggers a <em>proem.init</em> event
    and creates a new <em>Filter Manager</em>, passing it our <em>Service Manager</em> instance.
  </p>
  <p>
    So WTF is this <em>Filter Manager</em>?
  </p>
</div>
<div class="well">
  <h3>The Bootstrap Filter Chain</h3>
  <p>
    Before I explain what the <em>Bootstrap's Filter Chain</em> (Managed by the FilterManager) is and the functionality it provides it's probably a good idea to show you
    a simple example of the <em>Filter Chain</em> pattern which is a loose variation on the <a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">Chain of Responsibility</a> pattern.
  </p>
  <pre class="prettyprint">
    class Event1
    {
        public function execute($events)
        {
            echo "in Event1\n";
            if ($e = next($events)) {
                $e->execute($events);
            }
            echo "out Event1\n";
        }
    }

    class Event2
    {
        public function execute($events)
        {
            echo "in Event2\n";
            if ($e = next($events)) {
                $e->execute($events);
            }
            echo "out Event2\n";
        }
    }

    class Chain {
        private $events;

        public function __construct()
        {
            $this->events[] = new Event1;
            $this->events[] = new Event2;
        }

        public function start()
        {
            current($this->events)->execute($this->events);
        }
    }

    (new Chain)->start();
  </pre>
  <p>
    If you run this code you will see the output:
  </p>
  <pre>
    in Event1
    in Event2
    out Event2
    out Event1
  </pre>
  <p>
    The Chain is basically a bunch of objects that execute each other in a series.
  </p>
  <p>
    While the Proem's Filter Chain implementation is quite a bit more robust than this simple example, the basic premise is the same
    and the Proem object's init() method merely kicks off this process. It simply executes a series of events that are specifically designed to
    get the framework up and running.
  </p>
</div>
<div class="well">
  <h3>So what Filter Events are involved in bootstrapping?</h3>
  <p>
    So what Events does Proem's init() method execute? If we look at the <a href="#init">code</a> again you can see the events:
  </p>
  <ul>
    <li>Response</li>
    <li>Request</li>
    <li>Route</li>
    <li>Dispatch</li>
  </ul>
  <p>
    As there names suggest, these Events are responsible for setting up the Request, Response, Routing and Dispatch parts of the framework.
    Each of these events extend the <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Filter/Event/Generic.php">Proem\Filter\Event\Generic</a> object
    which is as I said little more robust (along with the <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Filter/Manager/Standard.php">Filter Manager</a> <em>(Chain)</em>) than the simple example shown above.
  </p>
  <p>
    One of the main differences is that each of these <em>Filter Events</em> has it's own <strong>in</strong>Bound and <strong>out</strong>Bound methods.
    These basically take the place of the <em>echo "in Event1</em> and <em>echo "out Event1</em> parts of the simple example above.
  </p>
  <div class="alert alert-notice">
    The Filter Component itself is yet to be documented, however it <a href="https://github.com/proem/proem/issues/80">is planned</a>.
  </div>
  <p>
    So, with all that in mind hopefully you can see that the Proem object's init() method executes the following process:
  </p>
  <ul>
    <li>Response inBound: <em>Setup the Response object</em></li>
    <li>Request inBound: <em>Setup the response object</em></li>
    <li>Route inBound: <em>Setup The Route object</em></li>
    <li>Dispatch inBound: <em>Yet to be implemented</em></li>
    <li>Dispatch outBound</li>
    <li>Route outBound</li>
    <li>Request outBound</li>
    <li>Response outBound: <em>Send response to client</em></li>
  </ul>
  <p>
    These Filter Events do the bulk of the grunt work involved with setting up the framework ready to bootstrap an application.
  </p>
</div>
<div class="well">
  <h3>How can we customise this process?</h3>
  <p>
    So now we have an understanding of what happens when we call <em>(new Proem\Proem)->init()</em>, but how can we customise this process? If you look again
    at the <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Filter/Event/Generic.php">Proem\Filter\Event\Generic</a> abstract you will notice
    <strong>pre*</strong> and <strong>post*</strong> methods surround the <strong>inBound</strong> and <strong>outBound</strong> methods. These pre / post methods
    are responsible for publishing <a href="http://dev.web/docs/signal-component.html">Signals</a> which we can lisen to in order to customise the bootstrap process.
  </p>
  <p>
    This means that the Chain publishes 16 different events that we can listen to using the <a href="/docs/signal-component.html">Signals</a> component. On top of that, there is the initial "proem.init" event
    which we can also see within the <a href="#init">init()</a> code. The Singnals involved are:
  </p>
  <ul>
    <li>proem.init</li>
    <li>pre.in.response</li>
    <li>post.in.response</li>
    <li>pre.in.request</li>
    <li>post.in.request</li>
    <li>pre.in.router</li>
    <li>post.in.router</li>
    <li>pre.in.dispatch</li>
    <li>post.in.dispatch</li>
    <li>pre.out.dispatch</li>
    <li>post.out.dispatch</li>
    <li>pre.out.route</li>
    <li>post.out.route</li>
    <li>pre.out.request</li>
    <li>post.out.request</li>
    <li>pre.out.response</li>
    <li>post.out.response</li>
  </ul>
</div>
<div class="well">
  <h3>So what do we do with all these signals?</h3>
  <p>
    All of the above mentioned signals are entry points to the framework. These are the events we can listen for and act upon in order
    to customise the bootstrap process.
  </p>
  <p>
    For instance, out of the box there are no <em>Routes</em> set up by Proem. If we want to add a <em>Route</em> to the <em>Router</em> we can do so by
    waiting for the <em>Router</em> to exist, and then access it and add our <em>Route</em>.
  <p>
</div>
<div class="well">
  <a name="attach-events"></a>
  <h3>A simple example, adding a <em>Route</em> to the <em>Router</em></h3>
  <pre class="prettyprint">
    namespace MyApp;

    require_once 'phar://proem.phar';

    (new \Proem\Proem)->attachEventListener([
        'name' => 'post.in.route',
        'callback' => function($e) {
            $e->getServiceManager()->get('router')->map(
                'logout', new \Proem\Routing\Route\Standard([
                    'rule'      => '/logout',
                    'targets'   => ['controller' => 'auth', 'action' => 'logout']
                ])
            );
        }
    ])->init();
  </pre>
  <p>
    In this example we can see that the <em>Proem</em> object provides an <em>attachEventListener()</em> method. This method proxies through and attaches listeners
    to the main <a href="/docs/signal-component.html">Signal Manager</a> that is passed around the framework.
  <p>
    If you have read the <a href="/docs/signal-component.html">Signal Component</a> documentation you will know that the <strong><em>$e</em></strong> in this
    example represents the <em>Event</em> that was triggered.
  </p>
  <p>
    All Events triggered during the <em>bootstrap process</em> are instances of the custom
    <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Bootstrap/Signal/Event/Bootstrap.php">Bootstrap Signal Event</a> which provides a few extra methods
    that are specific to the bootstrap process. <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Bootstrap/Signal/Event/Bootstrap.php#L67">getServiceManager()</a> is
    one such method and provides us access to the Services that have been set up.
  </p>
  <p>
    Because we are listening for the <strong>post.in.route</strong> event, the router already exists and is within the <em>Service Manager</em> ready for us to customise.
  </p>
  <p>
    But what if we don't want to use the <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Routing/Router/Standard.php">Standard Router</a>? We could go down the
    <a href="http://dev.web/docs/cascading-namespace.html">Cascading Namespace</a> path and overload it that way, or, using the <em>Events</em> provided we can overload it on the fly.
  </p>
</div>
<div class="well">
  <h3>Overloading provided services</h3>
  <p>
    For whatever reason we have decided that we need our <em>Router</em> to implement a useless <em>helloWorld</em> method. How do we overload the <em>Router</em> that Proem is
    going to provide us with by default? Easy.
  <p>
  <p>
    The <em>Router</em> is created within the Router Filter Chain Event <em>inBound()</em>. All we need do is listen for the <strong>pre.in.route</strong> event and from within our listener, return a
    new <em>Router</em> wrapped within a <a href="/docs/services-component.html">Service Asset Container</a> (Being sure to pass it a valid uri to it's constructor).
  </p>
  <pre class="prettyprint">
    namespace MyApp;

    require_once 'phar://proem.phar';

    // You would normally define this somewhere else and autoload it.
    class Router extends \Proem\Routing\Router\Standard
    {
        public function helloWorld()
        {
            return 'Boo!';
        }
    }

    (new \Proem\Proem)->attachEventListener([
        'name' => 'pre.in.route',
        'callback' => function($e) {
            return (new \Proem\Service\Asset\Generic)->set('MyApp\Router', function() use ($e) {
                return new MyApp\Router($e->getServiceManager()->get('request')->getBaseUri());
            });
        }
    ])->init();
  </pre>
</div>
<div class="well">
  <h3>So what Events do what?</h3>
  <p>
    I'm a little hesitant to document this at this early stage. It's safe to say however that any if the pre.in.* event's will accept a listener
    that can return an <em>Asset</em> holding a <em>Service</em>. Eg; The <em>pre.in.request</em> Event could return an implementation of the
    <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/IO/Request/Template.php">Request Template</a>.The following inBound()
    <em>Chain Event</em> will then use this to populate the <em>Service Manager</em> instead of creating it's default.
  </p>
  <p>
    The waters get a bit more unclear when we start dealing with the <em>Response</em> object which is set up on the inBound() <em>Chain Event</em> but will actually
    also do some work on the way <em>out</em> of the chain.
  </p>
  <p>
    For instance, if you take a look at the <a href="https://github.com/proem/proem/blob/develop/lib/Proem/Api/Bootstrap/Filter/Event/Response.php#L136">outBound</a>
    method on the <em>Response Filter Event</em> you can see that this is used to send any response to the client.
  </p>
</div>
<div class="well">
  <h3>Summary</h3>
  <p>
    I hope this has cleared up a lot about how the bootstrap process is intended to work within Proem. I trust that you can see how easy it is going to be to
    customise this process to your needs.
  </p>
  <p>
    I can also hear people screaming that "by the time I listen for all these events my bootstrap is going to be a mess!". While this might look like the case at this
    point in time there are already processes in place to work around this. The <a href="https://github.com/proem/proem/tree/develop/lib/Proem/Api/Ext">Ext</a> name space
    adds the ability to load <em>Plugins</em> and <em>Modules</em> that are used to group event listeners into self contained name spaces of code that you can load into
    your bootstrap (this stuff is just <a href="https://github.com/proem/proem/issues/80">yet to be documented</a>).
  </p>
  <p>
    There is also likely to be some form of configuration layer added over the top of the Bootstrap when the current API becomes a little more stable.
  </p>
</div>
        </div>
      </div>
    </div>
      </body>
</html>
