<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Proem Framework &mdash; A lightweight, simple, fast MVC implementation for PHP5.4</title>
    <meta name="description" content="">
    <meta name="author" content="Tony R Quilkey">
    <meta name="viewport" content="width=device-width, initial-scale=1.1">

    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="/scripts/bootstrap.min.js"></script>
    <script src="/scripts/prettify.js"></script>
    <script src="/scripts/proem.js"></script>

    <link rel="stylesheet" type="text/css" href="/styles/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/styles/bootstrap-responsive.min.css">
    <link rel="stylesheet" type="text/css" href="/styles/prettify.css">
    <link rel="stylesheet" type="text/css" href="/styles/proem.css">
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-21713077-3']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
  </head>
  <body>
    <div class="topnav">
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <div class="brand">
            <strong>Proem</strong> Framework
          </div>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/docs">Documentation</a></li>
              <!--<li><a href="/contrib">Contribute</a></li>-->
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
    <div class="docs container">
      <div class="row">
        <div class="span3">
          <ul class="nav nav-tabs nav-stacked">
            <li><a href="/docs">Overview</a></li>
            <li><a href="/docs/installation.html">Installation</a></li>
            <li><a href="/docs/autoloader.html">The Autoloader</a></li>
            <li><a href="/docs/cascading-namespace.html">The Cascading Namespace</a></li>
            <li><a href="/docs/opt-component.html">The Opt Component</a></li>
            <li><a href="/docs/route-component.html">Routing</a></li>
            <li><a href="/docs/signal-component.html">Signals</a></li>
            <li><a href="/docs/services-component.html">Dependency Injection</a></li>
          </ul>
        </div>
        <div class="span9">
          <div class="well">
  <h1>The cascading name space</h1>
  <p>
    The entire Proem framework sits within the <em>Proem\Api</em> name space, yet internally it uses a virtual name space
    called <em>Proem</em>, users also use this same <em>virtual</em> name space when using Proem. This name space doesn't
    actually exist, yet you can declare your own versions of classes within this name space in order to have your
    functionality override provided by the framework.
  </p>
</div>
<div class="well">
  <h3>A simple example</h3>
  <p>
    An example might explain this better. Lets take a look at the <em>Options</em> trait. This trait's usage is
    explained <a href="/docs/opt-component">here</a>, but it basically imports a single setDefaults() method, allowing
    us to implement very simple <em>named arguments</em> functionality. Internally, this method depends on the <em>Option</em> class.
  </p>
  <pre class="prettyprint">
    foreach ($options as $key => $value) {
        if (isset($defaults[$key]) && ($defaults[$key] instanceof Option)) {
            $defaults[$key]->setValue($value);
        } else {
            $defaults[$key] = new Option($value);
        }
    }
  </pre>
  <p>
    Now, in this particular example you can get around most of the problem by simply extending the <em>Option</em> object
    and using it instead wherever you need to use setDefaults().
  </p>
  <pre class="prettyprint">
    class MyOption extends Proem\Util\Opt\Option {}

    class example
    {
        use Options;

        public function foo(array $options = array())
        {
            $ops = $this->setOptions([
                'foo' => 'somevalue',
                'bar' => (new MyOption())->required()
            ], $options);
        }
    }
  </pre>
  <p>
    You can still see however that if you simply pass a value (like we did with the "foo" option, it will automatically
    instantiate Proem's <em>Option</em> object for you. Normally, you couldn't override this default behaviour
    without actually hacking the framework.
  </p>
  <p>This is where the <em>cascading name space</em> comes into play.</em>
</div>
<div class="well">
  <h3>A more complete example</h3>
  <p>
    Let's say Proem is residing in /usr/share/proem/lib, and we have our project in /home/foo/project. We can create
    our own <em>Proem</em> name space within that name space and override the <em>Option</em> class.
  </p>
  <p><i>/home/foo/project/Proem/Util/Opt/Option.php</i></p>
  <pre class="prettyprint">
    name space Proem;

    class Option extends \Proem\Api\Util\Opt\Option 
    {
        public function __construct($value = __FILE__) {
            parent::__construct();

            $this->addTypeValidator(
                'null',
                function($value) {
                    return is_null($value);
                }
            );
        }
    }
  </pre>
  <p>You then need to make sure that the AutoLoader is setup to find your directory before it find the framework itself.</p>
  <pre class="prettyprint">
    require_once '/usr/share/proem/lib/Proem/Autoloader.php';

    $loader = new Proem\AutoLoader();
    $loader->registerNamespaces([
        'Proem' => ['/home/foo/project', '/usr/share/proem/lib']
    ])->register();
  </pre>
  <p>
    The trick is to declare your class within the Proem name space (used both internally and by applications built on top of
    Proem) and to extend the corresponding object from within Proem\Api. This new custom class will then be used throughout
    the entire framework and your application wherever the original <em>Option</em> object was previously used.
  </p>
  <div class="alert alert-info">
    On a side note: You may have noticed that the bootstrap example at the bottom of this page also uses the Autoloader from
    the Proem name space. You might wonder how this is possible if the magic happens in the Autoloader itself? Well, the
    Autoloader is the only class which is actually defined in the \Proem name space.
  </div>
</div>
        </div>
      </div>
    </div>
      </body>
</html>
